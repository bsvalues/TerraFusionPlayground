<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TerraFusion WebSocket Test</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
    }
    pre {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      overflow: auto;
      border: 1px solid #e9ecef;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
      font-size: 14px;
    }
    button:hover {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    input {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-size: 14px;
      width: 300px;
    }
    .connection-status {
      padding: 10px 15px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    .connected {
      background-color: #d4edda;
      color: #155724;
    }
    .disconnected {
      background-color: #f8d7da;
      color: #721c24;
    }
    .connecting {
      background-color: #fff3cd;
      color: #856404;
    }
    .log-container {
      height: 300px;
      overflow-y: auto;
    }
    .info {
      margin-top: 30px;
      padding: 15px;
      background-color: #e7f5fe;
      border-left: 5px solid #3498db;
      border-radius: 3px;
    }
    .error {
      color: #721c24;
    }
  </style>
</head>
<body>
  <h1>TerraFusion WebSocket Test</h1>
  
  <div id="status" class="connection-status disconnected">Disconnected</div>
  
  <div>
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
  </div>
  
  <h2>Send Message</h2>
  <div>
    <input type="text" id="message" placeholder="Enter message..." value="Hello from WebSocket client">
    <button id="send" disabled>Send</button>
  </div>
  
  <h2>Communication Log</h2>
  <div class="log-container">
    <pre id="log"></pre>
  </div>
  
  <div class="info">
    <h3>WebSocket Connection Information</h3>
    <p>This page tests the TerraFusion WebSocket server running on the <code>/ws</code> path.</p>
    <p>The WebSocket server is configured to:</p>
    <ul>
      <li>Echo messages back with timestamp</li>
      <li>Send a welcome message on connection</li>
      <li>Support real-time monitoring updates</li>
    </ul>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const connectBtn = document.getElementById('connect');
      const disconnectBtn = document.getElementById('disconnect');
      const sendBtn = document.getElementById('send');
      const messageInput = document.getElementById('message');
      const logElement = document.getElementById('log');
      const statusElement = document.getElementById('status');
      
      let socket = null;
      let reconnectAttempts = 0;
      const MAX_RECONNECT_ATTEMPTS = 3;
      let reconnectTimer = null;
      let usingFallback = false;
      
      function updateStatus(status, message) {
        statusElement.className = `connection-status ${status}`;
        statusElement.textContent = message;
      }
      
      function log(message, error = false) {
        const entry = document.createElement('div');
        entry.textContent = `[${new Date().toISOString()}] ${message}`;
        if (error) entry.className = 'error';
        logElement.appendChild(entry);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      // Display a fallback connection notice at the top of the page
      function showFallbackNotice() {
        const noticeContainer = document.createElement('div');
        noticeContainer.id = 'fallback-notice';
        noticeContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background-color: #fff3cd;
          color: #856404;
          padding: 10px;
          text-align: center;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          z-index: 1000;
        `;
        
        noticeContainer.innerHTML = `
          <div>
            <strong>WebSocket Connection Issue</strong><br>
            The system is currently using a fallback connection method. Real-time updates may be delayed.
          </div>
          <div style="margin-top: 5px">
            <button id="reconnect-btn" style="background-color: #856404; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 10px;">Reconnect</button>
            <button id="dismiss-btn" style="background-color: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
          </div>
        `;
        
        document.body.prepend(noticeContainer);
        
        // Add event listeners to buttons
        document.getElementById('reconnect-btn').addEventListener('click', () => {
          document.getElementById('fallback-notice').remove();
          reconnectAttempts = 0;
          connectToWebSocket();
        });
        
        document.getElementById('dismiss-btn').addEventListener('click', () => {
          document.getElementById('fallback-notice').remove();
        });
      }
      
      function connectToWebSocket() {
        if (socket) {
          log('Already connected, disconnecting first...');
          socket.close();
        }
        
        updateStatus('connecting', 'Connecting...');
        log('Attempting to connect to WebSocket server...');
        
        try {
          // 1. Try standard WebSocket connection
          // Create WebSocket connection with the correct protocol (ws/wss)
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;
          log(`Connecting to: ${wsUrl}`);
          
          socket = new WebSocket(wsUrl);
          
          socket.onopen = (event) => {
            log('Connection established successfully!');
            updateStatus('connected', 'Connected');
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            sendBtn.disabled = false;
            reconnectAttempts = 0;
            usingFallback = false;
          };
          
          socket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              log(`Received: ${JSON.stringify(data, null, 2)}`);
            } catch (e) {
              log(`Received non-JSON message: ${event.data}`);
            }
          };
          
          socket.onclose = (event) => {
            const reason = event.reason ? ` Reason: ${event.reason}` : '';
            log(`Connection closed. Code: ${event.code}.${reason}`);
            
            // Check if we should try to reconnect
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && event.code === 1006) {
              reconnectAttempts++;
              log(`Reconnect attempt ${reconnectAttempts} of ${MAX_RECONNECT_ATTEMPTS}...`);
              
              const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000);
              updateStatus('connecting', `Reconnecting in ${delay/1000}s...`);
              
              reconnectTimer = setTimeout(() => {
                if (reconnectAttempts === MAX_RECONNECT_ATTEMPTS) {
                  log('Maximum reconnection attempts reached. Using fallback mode.', true);
                  initiateFallbackMode();
                } else {
                  connectToWebSocket();
                }
              }, delay);
            } else {
              if (!usingFallback && event.code === 1006) {
                log('Connection failed. Using fallback mode.', true);
                initiateFallbackMode();
              } else {
                updateStatus('disconnected', 'Disconnected');
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                sendBtn.disabled = true;
              }
            }
            
            socket = null;
          };
          
          socket.onerror = (error) => {
            log(`WebSocket error: ${error.message || 'Unknown error'}`, true);
            if (!usingFallback) {
              updateStatus('disconnected', 'Error - See log');
            }
          };
        } catch (error) {
          log(`Failed to create WebSocket connection: ${error.message}`, true);
          updateStatus('disconnected', 'Connection Failed');
          
          // If we can't even create a WebSocket, go straight to fallback
          if (!usingFallback) {
            initiateFallbackMode();
          }
        }
      }
      
      function initiateFallbackMode() {
        usingFallback = true;
        showFallbackNotice();
        updateStatus('connected', 'Connected (Fallback Mode)');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        sendBtn.disabled = false;
        
        // Set up Server-Sent Events (SSE) as fallback communication
        log('Fallback mode initiated - connecting to SSE endpoint');
        
        // Capture some data for metrics
        const clientId = `client_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        const currentUrl = window.location.href;
        const currentRoute = window.location.pathname;
        
        // Report fallback usage to metrics endpoint
        try {
          fetch('/api/web-vitals/custom-event', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              metric: 'websocket_fallback_total',
              labels: {
                reason: 'connection_failure',
                client_id: clientId,
                url: currentUrl,
                route: currentRoute
              }
            })
          });
        } catch (error) {
          console.error('Failed to report metrics:', error);
        }
        
        // Start the SSE connection
        startSSEConnection(clientId);
      }
      
      // Connect to the Server-Sent Events endpoint
      let eventSource = null;
      function startSSEConnection(clientId) {
        // Close any existing SSE connection
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        
        // Connect to the SSE endpoint with client ID
        const sseUrl = `/api/events?clientId=${encodeURIComponent(clientId)}`;
        log(`Connecting to SSE endpoint: ${sseUrl}`);
        
        try {
          eventSource = new EventSource(sseUrl);
          
          // Handle successful connection
          eventSource.onopen = () => {
            log('SSE connection established successfully');
          };
          
          // Handle incoming messages
          eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              log(`Received (SSE): ${JSON.stringify(data, null, 2)}`);
            } catch (error) {
              log(`Received non-JSON SSE message: ${event.data}`);
            }
          };
          
          // Handle errors
          eventSource.onerror = (error) => {
            log(`SSE connection error: ${error.message || 'Unknown error'}`, true);
            
            // If the connection is closed, try to reconnect
            if (eventSource.readyState === EventSource.CLOSED) {
              log('SSE connection closed, attempting to reconnect...');
              
              // Wait a moment before reconnecting
              setTimeout(() => {
                if (usingFallback) {
                  startSSEConnection(clientId);
                }
              }, 3000);
            }
          };
        } catch (error) {
          log(`Failed to connect to SSE endpoint: ${error.message}`, true);
          
          // Fall back to simulated polling as a last resort
          log('Falling back to simulated polling mode');
          startSimulatedPolling();
        }
      }
      
      // Simulate polling for messages as a last-resort fallback
      let fallbackPollInterval = null;
      function startSimulatedPolling() {
        fallbackPollInterval = setInterval(() => {
          if (usingFallback) {
            const fallbackResponse = {
              type: 'simulated_fallback',
              message: 'This is a simulated message (last-resort fallback)',
              timestamp: new Date().toISOString(),
              pollingId: Math.random().toString(36).substring(2, 15)
            };
            log(`Received (simulated): ${JSON.stringify(fallbackResponse, null, 2)}`);
          }
        }, 5000);
      }
      
      function stopFallbackConnections() {
        // Close SSE connection if active
        if (eventSource) {
          log('Closing SSE connection');
          eventSource.close();
          eventSource = null;
        }
        
        // Stop simulated polling if active
        if (fallbackPollInterval) {
          log('Stopping simulated polling');
          clearInterval(fallbackPollInterval);
          fallbackPollInterval = null;
        }
      }
      
      connectBtn.addEventListener('click', () => {
        reconnectAttempts = 0;
        usingFallback = false;
        stopFallbackPolling();
        connectToWebSocket();
      });
      
      disconnectBtn.addEventListener('click', () => {
        if (socket) {
          log('Closing WebSocket connection...');
          socket.close();
        }
        
        if (usingFallback) {
          log('Ending fallback connection...');
          stopFallbackConnections();
          usingFallback = false;
          updateStatus('disconnected', 'Disconnected');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          sendBtn.disabled = true;
          
          // Remove fallback notice if it exists
          const notice = document.getElementById('fallback-notice');
          if (notice) notice.remove();
        }
        
        // Clear any pending reconnect timers
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      });
      
      sendBtn.addEventListener('click', () => {
        const message = messageInput.value.trim();
        if (!message) {
          log('Cannot send empty message');
          return;
        }
        
        // Regular WebSocket send
        if (socket && socket.readyState === WebSocket.OPEN) {
          try {
            // Try to send as JSON
            const jsonMessage = { text: message, timestamp: new Date().toISOString() };
            log(`Sending: ${JSON.stringify(jsonMessage)}`);
            socket.send(JSON.stringify(jsonMessage));
          } catch (error) {
            log(`Error sending message: ${error.message}`, true);
          }
        } 
        // Fallback mode send
        else if (usingFallback) {
          try {
            const jsonMessage = { 
              text: message, 
              timestamp: new Date().toISOString(),
              mode: 'fallback'
            };
            log(`Sending (fallback): ${JSON.stringify(jsonMessage)}`);
            
            // Make an HTTP POST request to send messages when using SSE fallback
            fetch('/api/ws-fallback/send', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: jsonMessage,
                clientId: clientId // Use the clientId from the SSE connection
              })
            })
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }
              return response.json();
            })
            .then(data => {
              log(`Message sent via HTTP fallback: ${JSON.stringify(data, null, 2)}`);
            })
            .catch(error => {
              log(`Error sending message via HTTP fallback: ${error.message}`, true);
              
              // Simulate a response for testing when the endpoint isn't available yet
              const response = {
                type: 'echo',
                originalMessage: jsonMessage,
                timestamp: new Date().toISOString(),
                via: 'fallback',
                note: 'Simulated response (endpoint not available)'
              };
              log(`Received (simulated fallback): ${JSON.stringify(response, null, 2)}`);
            });
          } catch (error) {
            log(`Error sending fallback message: ${error.message}`, true);
          }
        } else {
          log('Cannot send message, not connected', true);
        }
      });
      
      // Allow pressing Enter to send a message
      messageInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter' && !sendBtn.disabled) {
          sendBtn.click();
        }
      });
      
      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        if (socket) {
          socket.close();
        }
        stopFallbackConnections();
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
      });
      
      // Display WebSocket information on page load
      log('WebSocket test page loaded');
      
      // Auto-connect if the URL has ?autoconnect=true
      if (new URLSearchParams(window.location.search).get('autoconnect') === 'true') {
        log('Auto-connect enabled, connecting...');
        connectBtn.click();
      }
    });
  </script>
</body>
</html>