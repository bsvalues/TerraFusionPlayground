<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket Test</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
    }
    h1, h2 {
      color: #2c3e50;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .connection-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .status-indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: #e74c3c;
    }
    .status-indicator.connected {
      background-color: #2ecc71;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    input, button, select {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    input {
      flex-grow: 1;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    #message-log {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      height: 300px;
      overflow-y: auto;
      background-color: #f9f9f9;
      margin-top: 10px;
    }
    .message {
      padding: 8px;
      margin-bottom: 6px;
      border-radius: 4px;
    }
    .message.received {
      background-color: #e8f4fd;
      border-left: 4px solid #3498db;
    }
    .message.sent {
      background-color: #f7fdf7;
      border-left: 4px solid #2ecc71;
    }
    .message.info {
      background-color: #f9f4d9;
      border-left: 4px solid #f1c40f;
    }
    .message.error {
      background-color: #fdeded;
      border-left: 4px solid #e74c3c;
    }
    .timestamp {
      font-size: 0.8em;
      color: #7f8c8d;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 5px 0;
      font-size: 0.9em;
    }
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
      margin-right: 5px;
    }
    .badge.sent {
      background-color: #2ecc71;
      color: white;
    }
    .badge.received {
      background-color: #3498db;
      color: white;
    }
    .badge.info {
      background-color: #f1c40f;
      color: #34495e;
    }
    .badge.error {
      background-color: #e74c3c;
      color: white;
    }
    .badge.ping {
      background-color: #9b59b6;
      color: white;
    }
    .metric {
      display: inline-block;
      padding: 5px 10px;
      background-color: #ecf0f1;
      border-radius: 4px;
      margin-right: 10px;
      font-size: 0.9em;
    }
    #connection-metrics {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    @media (max-width: 600px) {
      .actions {
        flex-direction: column;
      }
      .input-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <h1>WebSocket Test Page</h1>
  <p>This page demonstrates WebSocket connectivity with fallback capability to Server-Sent Events (SSE).</p>
  
  <div class="container">
    <div class="card">
      <h2>Connection Status</h2>
      <div class="connection-status">
        <div id="status-indicator" class="status-indicator"></div>
        <span id="connection-status">Disconnected</span>
      </div>
      <div id="connection-details"></div>
      <div id="connection-metrics">
        <div class="metric">Messages sent: <span id="sent-count">0</span></div>
        <div class="metric">Messages received: <span id="received-count">0</span></div>
        <div class="metric">Connection attempts: <span id="connection-attempts">0</span></div>
        <div class="metric">Reconnections: <span id="reconnection-count">0</span></div>
      </div>
    </div>
    
    <div class="card">
      <h2>Send Message</h2>
      <div class="input-group">
        <input type="text" id="message-input" placeholder="Enter message" disabled>
        <button id="send-button" disabled>Send</button>
      </div>
      <div class="actions">
        <button id="connect-button">Connect WebSocket</button>
        <button id="disconnect-button" disabled>Disconnect</button>
        <button id="connect-sse-button">Use SSE Fallback</button>
      </div>
    </div>
    
    <div class="card">
      <h2>Message Log</h2>
      <div id="message-log"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Elements
      const statusIndicator = document.getElementById('status-indicator');
      const connectionStatus = document.getElementById('connection-status');
      const connectionDetails = document.getElementById('connection-details');
      const messageInput = document.getElementById('message-input');
      const sendButton = document.getElementById('send-button');
      const connectButton = document.getElementById('connect-button');
      const disconnectButton = document.getElementById('disconnect-button');
      const connectSSEButton = document.getElementById('connect-sse-button');
      const messageLog = document.getElementById('message-log');
      const sentCount = document.getElementById('sent-count');
      const receivedCount = document.getElementById('received-count');
      const connectionAttempts = document.getElementById('connection-attempts');
      const reconnectionCount = document.getElementById('reconnection-count');
      
      // Variables
      let socket = null;
      let eventSource = null;
      let messageCounter = { sent: 0, received: 0, attempts: 0, reconnects: 0 };
      let clientId = null;
      let connectionMode = null;
      let reconnectInterval = null;
      let reconnectAttempt = 0;
      let maxReconnectDelay = 30000; // 30 seconds max
      
      // Utility functions
      function updateConnectionStatus(connected, mode, details = '') {
        if (connected) {
          statusIndicator.classList.add('connected');
          connectionStatus.textContent = `Connected (${mode})`;
          messageInput.disabled = false;
          sendButton.disabled = false;
          disconnectButton.disabled = false;
          connectButton.disabled = true;
          connectSSEButton.disabled = true;
          connectionMode = mode;
        } else {
          statusIndicator.classList.remove('connected');
          connectionStatus.textContent = 'Disconnected';
          messageInput.disabled = true;
          sendButton.disabled = true;
          disconnectButton.disabled = true;
          connectButton.disabled = false;
          connectSSEButton.disabled = false;
          connectionMode = null;
        }
        connectionDetails.textContent = details;
      }
      
      function addMessageToLog(message, type, direction = null) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        
        // Create badge based on message type/direction
        const badge = document.createElement('span');
        badge.className = `badge ${direction || type}`;
        
        if (direction === 'sent') {
          badge.textContent = 'SENT';
          messageCounter.sent++;
          sentCount.textContent = messageCounter.sent;
        } else if (direction === 'received') {
          badge.textContent = 'RECEIVED';
          messageCounter.received++;
          receivedCount.textContent = messageCounter.received;
        } else if (type === 'ping') {
          badge.textContent = 'PING';
        } else if (type === 'info') {
          badge.textContent = 'INFO';
        } else if (type === 'error') {
          badge.textContent = 'ERROR';
        }
        
        // Create timestamp
        const timestamp = document.createElement('span');
        timestamp.className = 'timestamp';
        timestamp.textContent = new Date().toLocaleTimeString();
        
        // Message content
        let content;
        if (typeof message === 'object') {
          const pre = document.createElement('pre');
          pre.textContent = JSON.stringify(message, null, 2);
          content = pre;
        } else {
          content = document.createTextNode(message);
        }
        
        // Assemble message div
        messageDiv.appendChild(badge);
        messageDiv.appendChild(document.createTextNode(' '));
        messageDiv.appendChild(timestamp);
        messageDiv.appendChild(document.createElement('br'));
        messageDiv.appendChild(content);
        
        messageLog.appendChild(messageDiv);
        messageLog.scrollTop = messageLog.scrollHeight;
      }
      
      // WebSocket Functions
      function connectWebSocket() {
        if (socket) {
          socket.close();
        }
        
        messageCounter.attempts++;
        connectionAttempts.textContent = messageCounter.attempts;
        
        try {
          // Use correct WebSocket protocol based on page protocol
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;
          
          addMessageToLog(`Attempting to connect to WebSocket: ${wsUrl}`, 'info');
          socket = new WebSocket(wsUrl);
          
          socket.onopen = function() {
            updateConnectionStatus(true, 'WebSocket', `Connected to ${wsUrl}`);
            addMessageToLog('WebSocket connection established', 'info');
            
            // Reset reconnect attempt counter and clear interval
            reconnectAttempt = 0;
            if (reconnectInterval) {
              clearInterval(reconnectInterval);
              reconnectInterval = null;
            }
            
            // If we were previously using SSE, close it
            if (eventSource) {
              addMessageToLog('WebSocket reconnected, closing SSE fallback', 'info');
              eventSource.close();
              eventSource = null;
            }
          };
          
          socket.onmessage = function(event) {
            try {
              const data = JSON.parse(event.data);
              
              // Handle ping messages differently
              if (data.type === 'ping') {
                console.log('Ping received:', data);
                // Don't add pings to the message log to avoid spam
              } else {
                addMessageToLog(data, 'received', 'received');
              }
            } catch (error) {
              addMessageToLog(`Received raw message: ${event.data}`, 'received', 'received');
            }
          };
          
          socket.onerror = function(error) {
            addMessageToLog(`WebSocket error: ${error.message || 'Unknown error'}`, 'error');
            fallbackToSSE();
          };
          
          socket.onclose = function(event) {
            updateConnectionStatus(false);
            
            if (event.wasClean) {
              addMessageToLog(`WebSocket closed cleanly, code=${event.code}, reason=${event.reason}`, 'info');
            } else {
              addMessageToLog('WebSocket connection died', 'error');
              
              // Only auto-fallback to SSE if we're not already connected via SSE
              if (connectionMode !== 'SSE') {
                fallbackToSSE();
              } else if (!reconnectInterval) {
                // If already on SSE but no reconnect scheduled, schedule WebSocket reconnect
                scheduleWebSocketReconnect();
              }
            }
          };
        } catch (error) {
          addMessageToLog(`WebSocket connection error: ${error.message}`, 'error');
          fallbackToSSE();
        }
      }
      
      // SSE Functions
      function connectSSE() {
        if (eventSource) {
          eventSource.close();
        }
        
        if (socket) {
          socket.close();
          socket = null;
        }
        
        messageCounter.attempts++;
        connectionAttempts.textContent = messageCounter.attempts;
        
        try {
          clientId = `client_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
          const sseUrl = `/api/events?clientId=${clientId}`;
          
          addMessageToLog(`Attempting to connect to SSE: ${sseUrl}`, 'info');
          eventSource = new EventSource(sseUrl);
          
          eventSource.onopen = function() {
            updateConnectionStatus(true, 'SSE', `Connected to ${sseUrl}`);
            addMessageToLog('SSE connection established', 'info');
            messageCounter.reconnects++;
            reconnectionCount.textContent = messageCounter.reconnects;
          };
          
          eventSource.onmessage = function(event) {
            try {
              const data = JSON.parse(event.data);
              
              // Record the client ID if provided
              if (data.clientId) {
                clientId = data.clientId;
                connectionDetails.textContent = `Using SSE with client ID: ${clientId}`;
              }
              
              // Handle heartbeat messages differently
              if (data.type === 'heartbeat') {
                console.log('Heartbeat received:', data);
                // Don't add heartbeats to the message log to avoid spam
              } else {
                addMessageToLog(data, 'received', 'received');
              }
            } catch (error) {
              addMessageToLog(`Received raw SSE message: ${event.data}`, 'received', 'received');
            }
          };
          
          eventSource.onerror = function(error) {
            addMessageToLog(`SSE error: ${error.message || 'Unknown error'}`, 'error');
            eventSource.close();
            updateConnectionStatus(false);
          };
        } catch (error) {
          addMessageToLog(`SSE connection error: ${error.message}`, 'error');
          updateConnectionStatus(false);
        }
      }
      
      function calculateReconnectDelay() {
        // Exponential backoff with a maximum delay of maxReconnectDelay
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempt), maxReconnectDelay);
        reconnectAttempt++;
        return delay;
      }
      
      function scheduleWebSocketReconnect() {
        if (reconnectInterval) {
          clearInterval(reconnectInterval);
        }
        
        const delay = calculateReconnectDelay();
        addMessageToLog(`Scheduling WebSocket reconnect in ${delay/1000} seconds (attempt ${reconnectAttempt})`, 'info');
        
        reconnectInterval = setInterval(() => {
          if (connectionMode !== 'WebSocket') {
            addMessageToLog('Attempting to reconnect WebSocket...', 'info');
            connectWebSocket();
          } else {
            // Clear interval if we're already connected via WebSocket
            clearInterval(reconnectInterval);
            reconnectInterval = null;
            reconnectAttempt = 0;
          }
        }, delay);
      }
      
      function fallbackToSSE() {
        addMessageToLog('WebSocket failed, falling back to SSE', 'info');
        messageCounter.reconnects++;
        reconnectionCount.textContent = messageCounter.reconnects;
        connectSSE();
        
        // Schedule WebSocket reconnection attempts
        scheduleWebSocketReconnect();
      }
      
      function sendMessage() {
        const message = messageInput.value.trim();
        if (!message) return;
        
        if (connectionMode === 'WebSocket' && socket && socket.readyState === WebSocket.OPEN) {
          // Send via WebSocket
          const data = {
            action: 'echo',
            message: message,
            timestamp: new Date().toISOString(),
            clientId: clientId
          };
          
          socket.send(JSON.stringify(data));
          addMessageToLog(data, 'sent', 'sent');
          
        } else if (connectionMode === 'SSE' && clientId) {
          // Send via HTTP POST to SSE endpoint
          const data = {
            type: 'message',
            message: message,
            timestamp: new Date().toISOString(),
            clientId: clientId
          };
          
          fetch('/api/events/broadcast', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          })
          .then(response => response.json())
          .then(result => {
            addMessageToLog(data, 'sent', 'sent');
            console.log('Message sent via SSE API:', result);
          })
          .catch(error => {
            addMessageToLog(`Error sending message: ${error.message}`, 'error');
          });
        } else {
          addMessageToLog('Cannot send message - no active connection', 'error');
        }
        
        messageInput.value = '';
      }
      
      // Event Listeners
      connectButton.addEventListener('click', connectWebSocket);
      connectSSEButton.addEventListener('click', connectSSE);
      
      disconnectButton.addEventListener('click', function() {
        if (socket) {
          socket.close();
          socket = null;
        }
        
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        
        updateConnectionStatus(false);
        addMessageToLog('Disconnected by user', 'info');
      });
      
      sendButton.addEventListener('click', sendMessage);
      
      messageInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
          sendMessage();
        }
      });
      
      // Initialize page
      addMessageToLog('WebSocket Test Page loaded', 'info');
      addMessageToLog('Attempting to connect to WebSocket...', 'info');
      connectWebSocket();
    });
  </script>
</body>
</html>