Below is a consolidated, end-to-end plan for merging your disparate repositories into a unified TerraFusion monorepo, harmonizing CI/CD, documentation, and release processes. It leverages Git Subtrees for history preservation, Turborepo for build orchestration, reusable GitHub Actions workflows for CI/CD consistency, Docusaurus multi-instance for unified docs, and semantic-release-monorepo for automated releases.

Summary of Key Findings:
You’ll begin by selecting the most mature existing repo (e.g., TerraFusionMono) as your monorepo root and import all other codebases via git subtree to preserve commit history   . Next, you’ll incrementally adopt Turborepo to orchestrate builds and caching across packages without discarding existing package.json scripts   . CI/CD pipelines will be refactored into reusable GitHub Actions workflows, centralizing common logic and reducing duplication   . Documentation from multiple plugins will be consolidated into a Docusaurus multi-instance setup, enabling per-module sidebars and shared navigation   . Finally, your release process will be automated via semantic-release-monorepo, handling versioning and changelogs across all packages   .

⸻

1. Repository Consolidation with Git Subtrees

1.1 Choose the Monorepo Root

Select the most complete codebase—e.g., TerraFusionMono—as your monorepo root to avoid “starting over.”  

1.2 Import Each Repo via Subtrees

For each existing repo (e.g., BCBSLevy, PropertyTaxAI, etc.), run:

git remote add BCBSLevy https://github.com/bsvalues/BCBSLevy.git
git fetch BCBSLevy
git subtree add --prefix=apps/bcbs-levy BCBSLevy main --squash

This imports code and history under apps/… without losing Git metadata   .

1.3 Keep Them in Sync

To pull updates later:

git subtree pull --prefix=apps/bcbs-levy BCBSLevy main --squash

This workflow avoids git-submodule pitfalls and duplicates  .

⸻

2. Incremental Adoption of Turborepo

2.1 Scaffold turbo.json and Workspaces
	•	Create turbo.json at repo root.
	•	Define workspaces in pnpm-workspace.yaml (or package.json for Yarn/ npm):

packages:
  - "apps/*"
  - "packages/*"
```  [oai_citation:14‡Turborepo](https://turbo.build/docs/crafting-your-repository/structuring-a-repository?utm_source=chatgpt.com) [oai_citation:15‡Turborepo](https://turbo.build/docs?utm_source=chatgpt.com)  



2.2 Configure Basic Tasks

In turbo.json:

{
  "pipeline": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**"] },
    "test": { "dependsOn": ["build"], "outputs": [] }
  }
}

This enables parallel, cached task execution across all apps/packages  .

2.3 Migrate Existing Scripts

Modify each package.json to include standard scripts (build, test, lint, etc.). Turborepo will automatically pick them up.  

⸻

3. Harmonize CI/CD with Reusable Workflows

3.1 Create a Central .github/workflows/library.yml

Define common jobs (install, lint, test, build) as a reusable workflow:

# .github/workflows/library.yml
name: "Base CI"
on: workflow_call:
jobs:
  install:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: pnpm install
  lint:
    uses: ./.github/workflows/library.yml  # self-call for DRY
    with:
      steps: lint
    needs: install
# … etc.

3.2 Reference from Each App

In apps/bcbs-levy/.github/workflows/ci.yml:

name: "BCBS Levy CI"
on: [push, pull_request]
jobs:
  call-baseline:
    uses: your-org/terra-monorepo/.github/workflows/library.yml@main
    with:
      steps: [lint, build, test]

This enforces consistency and DRY across all pipelines   .

3.3 Parameterize and Version Your Workflows
	•	Pass variables (e.g., matrix of node versions).
	•	Tag reusable workflows semantically (e.g., @v1.0.0) to avoid breaking callers when updating  .

⸻

4. Consolidate Documentation with Docusaurus Multi-Instance

4.1 Install and Configure Plugins

Add two docs plugin instances in docusaurus.config.js:

presets: [
  [
    '@docusaurus/preset-classic',
    {
      docs: {
        id: 'core',
        path: 'docs/core',
        routeBasePath: 'docs/core',
        sidebarPath: './sidebarsCore.js',
      },
    },
  ],
],
plugins: [
  [
    '@docusaurus/plugin-content-docs',
    {
      id: 'plugins',
      path: 'docs/plugins',
      routeBasePath: 'docs/plugins',
      sidebarPath: './sidebarsPlugins.js',
    },
  ],
]

This isolates sidebars per docs set yet shares the same site   .

4.2 Autogenerate & Customize Sidebars

Use type: 'autogenerated' for each docs folder, and override sidebarItemsGenerator for shared nav links if needed  .

4.3 Single Build & Versioning

Run npm run build once at root to generate the full site, serving both docs sets seamlessly.  

⸻

5. Automate Releases with semantic-release-monorepo

5.1 Install and Configure

npm install -D semantic-release semantic-release-monorepo

In root .releaserc.json:

{
  "extends": "semantic-release-monorepo",
  "branches": ["main"],
  "monorepo": {
    "conventionalCommits": true
  }
}

This detects package-specific commits and tags each package appropriately   .

5.2 CI Integration

Add a release reusable workflow that runs npx semantic-release after successful build on the main branch.

⸻

6. Plugin Marketplace Interface & Governance
	1.	Signed Manifests: Ensure each plugin’s manifest.json includes peerVersion and a Cosign-verified signature.
	2.	Stripe Integration: Use Stripe webhooks to toggle premium flags for paid plugins.
	3.	Governance Rules: Automate plugin approval via CI checks (lint, SCA scans) and manual review for third-party submissions.

⸻

7. Onboarding New Counties & Contributors
	1.	Developer Guide: Publish a Markdown guide in docs/core/onboarding.md with steps to clone, set secrets, and run yarn dev.
	2.	Issue & PR Templates: Standardize contributions with templates under .github/ISSUE_TEMPLATE and .github/PULL_REQUEST_TEMPLATE.
	3.	Chatbot Agent: Integrate your AI support agent in the docs site for interactive troubleshooting (leveraging the CRM plugin).

⸻

8. Ongoing Maintenance & Scaling
	•	Performance Monitoring: Expose /metrics in your NestJS core and scrape with Prometheus/Grafana.
	•	Cache Efficiency: Ensure Turborepo remote cache is configured (e.g., AWS S3) to speed up CI runs.
	•	Version Lockstep: For interdependent packages, consider a fixed-mode release strategy (all packages bump together) via semantic-release-monorepo configuration.

⸻

By following this plan, you’ll transform your scattered codebases into a cohesive, maintainable, and scalable TerraFusion platform—complete with unified development workflows, centralized documentation, and enterprise-grade release automation.

Feel free to ask for further clarifications on any step!

