Below is the comprehensive migration and consolidation plan for turning an existing, mature codebase (bsvalues/PropertyTaxAI) into your unified TerraFusion monorepo—incrementally folding in other services (TerraFlow, BCBSLevy, GIS, etc.), standardizing CI/CD, centralizing docs, and stabilizing the plugin marketplace.

In summary, we recommend starting with PropertyTaxAI as the root (it already has a rich, modular client/server/shared structure), then using Git subtree to pull in each additional repo one by one, extracting shared packages for models/ETL/UI/AI, adopting Turborepo (or Nx) for fast incremental builds, replacing per-repo CI with reusable GitHub Actions workflows, scaffolding a Docusaurus docs site that aggregates markdown from all packages, and building a unified plugin-loader package plus a polished marketplace UI. Each step is backed by proven best practices with citations.

⸻

1. Choosing the Root Repository

bsvalues/PropertyTaxAI is your best foundation:
	•	It already contains client/, server/, and shared/ workspaces, mapping cleanly into apps/ and packages/ in a monorepo .
	•	Its robust CI templates, extensive tests, and LangChain AI integrations minimize unknowns when expanding to other modules.
	•	Rather than “starting over,” you build on a 714-commit, battle-tested stack ﹘ a classic incremental monorepo strategy  .

⸻

2. Incremental Migration via Git Subtree

Use git subtree to import each existing repo with history intact under packages/  :

# From PropertyTaxAI root:
git subtree add --prefix=packages/terraflow \
  https://github.com/bsvalues/TerraFlow.git main --squash

git subtree add --prefix=packages/bcbs-levy \
  https://github.com/bsvalues/BCBSLevy.git main --squash

# Repeat for GeospatialAnalyzerBS, GeoAssessmentPro, etc.

This approach preserves each project’s commit history, allows parallel development during migration, and avoids full rebase risks  .

⸻

3. Extract Shared Workspaces

Once each service lives under packages/, peel off common code into true shared packages:
	1.	packages/core-models
	•	Move all ORM definitions (Drizzle, SQLAlchemy) here.
	2.	packages/etl-connectors
	•	Consolidate PACS-DataBridge, CountyDataSync, TerraFusionSync scripts into connector plugins.
	3.	packages/ui
	•	Lift duplicate React components (maps, charts, tables) from each plugin.
	4.	packages/ai-core
	•	Centralize LangChain tools and prompt templates used across all agents.

Each extraction reduces duplication and speeds future changes  .

⸻

4. Monorepo Tooling & Incremental Builds

Install and configure Turborepo (or Nx) in-place to orchestrate tasks across all apps/ and packages/  :

npm install --save-dev turbo

Create turbo.json:

{
  "pipeline": {
    "build": { "dependsOn": ["^build"], "outputs": ["dist/**"] },
    "test": {}
  }
}

Now npx turbo run build test only rebuilds and retests affected packages, slashing CI time and enabling fast local iteration  .

⸻

5. Unified CI/CD with Reusable Workflows

Replace each repo’s bespoke CI with calls to a central terra-ci GitHub Actions repo using reusable workflows  :

# .github/workflows/ci.yml in each service/plugin
jobs:
  ci:
    uses: bsvalues/terra-ci/.github/workflows/ci.yml@main

Inside terra-ci, define:
	•	lint.yml: ESLint & Flake8
	•	test.yml: unit & integration tests
	•	build.yml: TypeScript transpilation, Docker image builds
	•	deploy.yml: staging/prod deployments (e.g., Blue/Green via Azure Container Apps)  

This ensures consistent quality gates and easy updates to CI policies across all modules.

⸻

6. Centralized Documentation Site

Scaffold a Docusaurus docs site under docs/ that aggregates markdown from every package via the plugin-content-docs multi-instance feature  :

npx create-docusaurus@latest docs classic

Configure sidebars.js to include:

module.exports = {
  core: [{type: 'autogenerated', dirName: '.'}],
  terraflow: [{type: 'autogenerated', dirName: '../packages/terraflow'}],
  // etc.
};

Add a GitHub Actions workflow to build & deploy docs on main merges ﹘ instant, versioned documentation for all contributors.

⸻

7. Plugin-Loader Package & Marketplace UI

In packages/plugin-loader, create:
	•	manifest.json schema: fields name, version, peerVersion, publicKey
	•	Verification utility: checks peerVersion against core via semver rules and validates signatures (peerDependencies as public API  ).
	•	Stripe integration: toggles premium plugin flags via webhook handling.

Update apps/web-shell/src/pages/Marketplace.tsx to:
	1.	Discover plugins by reading manifests
	2.	Install/Manage controls gated by auth roles
	3.	Polished UI: use lazy-loaded React cards, accessible ARIA labels, and consistent theming via design tokens.

⸻

8. Release, Versioning & Deployment

Adopt semantic-release for automated versioning and changelog generation in multi-package mode (e.g., multi-semantic-release)  :

npm install --save-dev semantic-release multi-semantic-release

Configure:

"release": {
  "branches": ["main"],
  "plugins": [
    ["@semantic-release/commit-analyzer"],
    ["@semantic-release/release-notes-generator"],
    ["@semantic-release/npm"],
    ["@semantic-release/github"]
  ]
}

Use Blue/Green or Canary deploys (Azure Container Apps example) to minimize risk during production releases  .

⸻

9. Ongoing Maintenance & Review
	•	Nightly Docs & Diagram Updates via scheduled Agent prompts
	•	Automated Issue Creation: Replit AI scans logs and opens GitHub issues for broken builds or alerts
	•	Periodic Architecture Reviews: Run the same consolidation prompts quarterly to catch new overlaps

By following this incremental, subtree-based, monorepo-orchestrated, and CI/CD-standardized plan—rooted in your most mature codebase—you’ll achieve a unified TerraFusion platform ready to scale to any county with minimal friction.

