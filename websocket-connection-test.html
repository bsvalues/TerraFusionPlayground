<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Connection Test Tool</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
        }
        h2 {
            color: #3498db;
            margin-top: 20px;
        }
        .connection-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .connection-form {
            flex: 1;
            min-width: 300px;
        }
        .connection-status {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .status-connected {
            background-color: #2ecc71;
        }
        .status-connecting {
            background-color: #f39c12;
        }
        .status-disconnected {
            background-color: #e74c3c;
        }
        .logs {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 10px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border-radius: 5px;
            font-family: monospace;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .message-panel {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .message-form {
            flex: 1;
        }
        .message-list {
            flex: 1;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .message {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        .message-sent {
            background-color: #d5f5e3;
            border-left: 3px solid #2ecc71;
        }
        .message-received {
            background-color: #eaeded;
            border-left: 3px solid #7f8c8d;
        }
        .tab-container {
            margin-top: 20px;
        }
        .tab-nav {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            color: #7f8c8d;
        }
        .tab-button.active {
            border-bottom: 2px solid #3498db;
            color: #3498db;
            font-weight: 600;
        }
        .tab-content {
            display: none;
            padding: 15px 0;
        }
        .tab-content.active {
            display: block;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        .protocol-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }
        .badge-ws {
            background-color: #3498db;
            color: white;
        }
        .badge-sse {
            background-color: #e67e22;
            color: white;
        }
        .badge-http {
            background-color: #9b59b6;
            color: white;
        }
        .metrics {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        .metric-card {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
        }
        .metric-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .toggle-label {
            margin-right: 10px;
            font-weight: 600;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2ecc71;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .error {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebSocket Connection Test Tool</h1>
        
        <div class="tab-container">
            <div class="tab-nav">
                <button class="tab-button active" data-tab="websocket">WebSocket</button>
                <button class="tab-button" data-tab="http-fallback">HTTP Fallback</button>
                <button class="tab-button" data-tab="sse">Server-Sent Events</button>
                <button class="tab-button" data-tab="diagnostics">Diagnostics</button>
            </div>
            
            <div id="websocket" class="tab-content active">
                <h2>WebSocket Connection <span class="protocol-badge badge-ws">WS</span></h2>
                
                <div class="connection-panel">
                    <div class="connection-form">
                        <div class="form-group">
                            <label for="websocket-url">WebSocket URL</label>
                            <input type="text" id="websocket-url" value="">
                        </div>
                        
                        <div class="toggle-switch">
                            <span class="toggle-label">Auto-reconnect</span>
                            <label class="switch">
                                <input type="checkbox" id="auto-reconnect" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-switch">
                            <span class="toggle-label">Binary Messages</span>
                            <label class="switch">
                                <input type="checkbox" id="binary-messages">
                                <span class="slider"></span>
                            </label>
                        </div>
                        
                        <div class="form-group">
                            <button id="connect-button">Connect</button>
                            <button id="disconnect-button" disabled>Disconnect</button>
                        </div>
                    </div>
                    
                    <div class="connection-status">
                        <h3>Status: <span id="connection-state">Disconnected</span> <span id="status-indicator" class="status-indicator status-disconnected"></span></h3>
                        <div class="metrics">
                            <div class="metric-card">
                                <div class="metric-value" id="latency">--</div>
                                <div class="metric-label">Latency (ms)</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="messages-sent">0</div>
                                <div class="metric-label">Sent</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="messages-received">0</div>
                                <div class="metric-label">Received</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="connection-time">--</div>
                                <div class="metric-label">Connected (s)</div>
                            </div>
                        </div>
                        <p id="connection-info"></p>
                    </div>
                </div>
                
                <div class="message-panel">
                    <div class="message-form">
                        <div class="form-group">
                            <label for="message-type">Message Type</label>
                            <select id="message-type">
                                <option value="message">Regular Message</option>
                                <option value="ping">Ping</option>
                                <option value="echo">Echo</option>
                                <option value="heartbeat">Heartbeat</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="message-content">Message Content</label>
                            <textarea id="message-content" rows="5">{"type": "message", "content": "Hello, WebSocket Server!"}</textarea>
                            <div id="message-error" class="error"></div>
                        </div>
                        <button id="send-button" disabled>Send Message</button>
                    </div>
                    
                    <div class="message-list" id="message-history">
                        <h3>Message History</h3>
                        <div id="messages"></div>
                    </div>
                </div>
                
                <div class="logs" id="connection-logs">
                    <div>WebSocket Connection Test Tool initialized</div>
                    <div>Available WebSocket endpoints:</div>
                    <div>- /ws (Main WebSocket Server)</div>
                    <div>- /ws-legacy (Legacy WebSocket Server)</div>
                    <div>- /ws/collaboration (Collaboration WebSocket)</div>
                    <div>- /ws/team-collaboration (Team WebSocket)</div>
                    <div>- /api/agents/ws (Agent WebSocket)</div>
                </div>
            </div>
            
            <div id="http-fallback" class="tab-content">
                <h2>HTTP Fallback <span class="protocol-badge badge-http">HTTP</span></h2>
                <p>This tab provides HTTP fallback functionality for environments where WebSockets are not available.</p>
                
                <div class="form-group">
                    <label for="http-endpoint">Fallback Endpoint</label>
                    <input type="text" id="http-endpoint" value="/api/ws-fallback/send">
                </div>
                
                <div class="form-group">
                    <label for="http-message">Message</label>
                    <textarea id="http-message" rows="5">{"type": "message", "content": "Hello via HTTP fallback!", "clientId": "http-client"}</textarea>
                </div>
                
                <button id="http-send-button">Send HTTP Request</button>
                
                <div class="logs" id="http-logs" style="margin-top: 20px;">
                    <div>HTTP Fallback ready</div>
                </div>
            </div>
            
            <div id="sse" class="tab-content">
                <h2>Server-Sent Events <span class="protocol-badge badge-sse">SSE</span></h2>
                <p>This tab tests Server-Sent Events (SSE) as an alternative to WebSockets.</p>
                
                <div class="form-group">
                    <label for="sse-endpoint">SSE Endpoint</label>
                    <input type="text" id="sse-endpoint" value="/api/events">
                </div>
                
                <button id="sse-connect-button">Connect to SSE</button>
                <button id="sse-disconnect-button" disabled>Disconnect</button>
                
                <div class="logs" id="sse-logs" style="margin-top: 20px;">
                    <div>SSE ready to connect</div>
                </div>
            </div>
            
            <div id="diagnostics" class="tab-content">
                <h2>Diagnostics</h2>
                <p>This tab provides diagnostic tools and environment information.</p>
                
                <div class="grid">
                    <div>
                        <h3>Environment</h3>
                        <div id="browser-info"></div>
                        <div id="network-info"></div>
                    </div>
                    <div>
                        <h3>Connection Tests</h3>
                        <button id="run-diagnostics">Run Connection Diagnostics</button>
                        <div class="logs" id="diagnostics-logs" style="margin-top: 20px;">
                            <div>Diagnostic tools ready</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Default WebSocket URL with protocol detection
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            document.getElementById('websocket-url').value = wsUrl;
            
            // Tab switching functionality
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // WebSocket variables
            let socket = null;
            let connectionState = 'disconnected';
            let connectionStartTime = null;
            let connectionTimer = null;
            let messagesSent = 0;
            let messagesReceived = 0;
            let latency = null;
            let pingInterval = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 5;
            let reconnectDelay = 1000; // Start with 1 second
            let reconnectTimeout = null;
            
            // DOM Elements
            const connectButton = document.getElementById('connect-button');
            const disconnectButton = document.getElementById('disconnect-button');
            const sendButton = document.getElementById('send-button');
            const connectionStateEl = document.getElementById('connection-state');
            const statusIndicator = document.getElementById('status-indicator');
            const connectionInfoEl = document.getElementById('connection-info');
            const messagesEl = document.getElementById('messages');
            const logsEl = document.getElementById('connection-logs');
            const latencyEl = document.getElementById('latency');
            const messagesSentEl = document.getElementById('messages-sent');
            const messagesReceivedEl = document.getElementById('messages-received');
            const connectionTimeEl = document.getElementById('connection-time');
            const messageTypeSelect = document.getElementById('message-type');
            const messageContentTextarea = document.getElementById('message-content');
            const messageErrorEl = document.getElementById('message-error');
            const autoReconnectCheckbox = document.getElementById('auto-reconnect');
            const binaryMessagesCheckbox = document.getElementById('binary-messages');
            
            // Utility functions
            function log(message) {
                const logItem = document.createElement('div');
                logItem.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                logsEl.appendChild(logItem);
                logsEl.scrollTop = logsEl.scrollHeight;
            }
            
            function updateConnectionState(state) {
                connectionState = state;
                connectionStateEl.textContent = state.charAt(0).toUpperCase() + state.slice(1);
                
                // Update status indicator
                statusIndicator.className = 'status-indicator';
                if (state === 'connected') {
                    statusIndicator.classList.add('status-connected');
                    
                    // Start connection timer
                    if (!connectionStartTime) {
                        connectionStartTime = Date.now();
                        startConnectionTimer();
                    }
                    
                    // Enable/disable buttons
                    connectButton.disabled = true;
                    disconnectButton.disabled = false;
                    sendButton.disabled = false;
                    
                    // Start ping for latency measurement
                    startPing();
                } else if (state === 'connecting') {
                    statusIndicator.classList.add('status-connecting');
                    connectButton.disabled = true;
                    disconnectButton.disabled = false;
                    sendButton.disabled = true;
                } else if (state === 'disconnected') {
                    statusIndicator.classList.add('status-disconnected');
                    
                    // Stop connection timer
                    if (connectionTimer) {
                        clearInterval(connectionTimer);
                        connectionTimer = null;
                    }
                    
                    // Reset connection time
                    connectionStartTime = null;
                    connectionTimeEl.textContent = '--';
                    
                    // Stop ping interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }
                    
                    // Enable/disable buttons
                    connectButton.disabled = false;
                    disconnectButton.disabled = true;
                    sendButton.disabled = true;
                }
            }
            
            function startConnectionTimer() {
                connectionTimer = setInterval(() => {
                    if (connectionStartTime) {
                        const duration = Math.floor((Date.now() - connectionStartTime) / 1000);
                        connectionTimeEl.textContent = duration;
                    }
                }, 1000);
            }
            
            function startPing() {
                // Clear any existing ping interval
                if (pingInterval) {
                    clearInterval(pingInterval);
                }
                
                // Send a ping message every 5 seconds to measure latency
                pingInterval = setInterval(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        const pingMessage = {
                            type: 'ping',
                            timestamp: Date.now()
                        };
                        sendMessage(pingMessage);
                    }
                }, 5000);
            }
            
            function addMessage(message, direction) {
                const messageEl = document.createElement('div');
                messageEl.className = `message message-${direction}`;
                
                let content;
                if (typeof message === 'object') {
                    try {
                        content = JSON.stringify(message, null, 2);
                    } catch (error) {
                        content = String(message);
                    }
                } else {
                    content = String(message);
                }
                
                if (content.length > 300) {
                    content = content.substring(0, 300) + '... (truncated)';
                }
                
                messageEl.textContent = content;
                messagesEl.appendChild(messageEl);
                messagesEl.scrollTop = messagesEl.scrollHeight;
            }
            
            function connectWebSocket() {
                try {
                    const url = document.getElementById('websocket-url').value;
                    updateConnectionState('connecting');
                    log(`Connecting to WebSocket at ${url}`);
                    
                    socket = new WebSocket(url);
                    
                    socket.addEventListener('open', (event) => {
                        log('WebSocket connection established');
                        updateConnectionState('connected');
                        reconnectAttempts = 0;
                        reconnectDelay = 1000;
                    });
                    
                    socket.addEventListener('message', (event) => {
                        messagesReceived++;
                        messagesSentEl.textContent = messagesSent;
                        messagesReceivedEl.textContent = messagesReceived;
                        
                        try {
                            let data;
                            if (event.data instanceof Blob) {
                                log('Received binary message');
                                // Handle binary data - for now just log it
                                const reader = new FileReader();
                                reader.onload = () => {
                                    try {
                                        const binaryData = reader.result;
                                        addMessage(`Binary data: ${binaryData.byteLength} bytes`, 'received');
                                    } catch (e) {
                                        addMessage(`Binary data (error parsing)`, 'received');
                                    }
                                };
                                reader.readAsArrayBuffer(event.data);
                                return;
                            } else {
                                data = JSON.parse(event.data);
                            }
                            
                            // Handle ping response for latency calculation
                            if (data.type === 'pong' && data.originalTimestamp) {
                                latency = Date.now() - data.originalTimestamp;
                                latencyEl.textContent = latency;
                            }
                            
                            log(`Received message: ${event.data.substring(0, 100)}${event.data.length > 100 ? '...' : ''}`);
                            addMessage(data, 'received');
                        } catch (error) {
                            log(`Error parsing message: ${error.message}`);
                            addMessage(event.data, 'received');
                        }
                    });
                    
                    socket.addEventListener('close', (event) => {
                        log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}`);
                        updateConnectionState('disconnected');
                        
                        // Handle reconnection if auto-reconnect is enabled
                        if (autoReconnectCheckbox.checked && reconnectAttempts < maxReconnectAttempts) {
                            reconnectAttempts++;
                            log(`Attempting to reconnect in ${reconnectDelay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                            
                            // Clear any existing timeout
                            if (reconnectTimeout) {
                                clearTimeout(reconnectTimeout);
                            }
                            
                            // Set reconnection timeout
                            reconnectTimeout = setTimeout(() => {
                                connectWebSocket();
                            }, reconnectDelay);
                            
                            // Exponential backoff
                            reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
                        } else if (reconnectAttempts >= maxReconnectAttempts) {
                            log('Maximum reconnection attempts reached. Please reconnect manually.');
                            connectionInfoEl.textContent = 'Maximum reconnection attempts reached. Please reconnect manually.';
                        }
                    });
                    
                    socket.addEventListener('error', (error) => {
                        log(`WebSocket error: ${error}`);
                    });
                } catch (error) {
                    log(`Error connecting to WebSocket: ${error.message}`);
                    updateConnectionState('disconnected');
                }
            }
            
            function disconnectWebSocket() {
                if (socket) {
                    log('Disconnecting WebSocket');
                    
                    // Clear any reconnection timeout
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                    
                    // Reset reconnection attempts
                    reconnectAttempts = 0;
                    
                    try {
                        socket.close(1000, 'User initiated disconnect');
                    } catch (error) {
                        log(`Error closing WebSocket: ${error.message}`);
                    }
                    
                    socket = null;
                    updateConnectionState('disconnected');
                }
            }
            
            function sendMessage(message) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    try {
                        let data;
                        
                        // Handle different message types
                        if (typeof message === 'object') {
                            if (binaryMessagesCheckbox.checked) {
                                // Send as binary
                                const jsonStr = JSON.stringify(message);
                                const encoder = new TextEncoder();
                                const binaryData = encoder.encode(jsonStr);
                                socket.send(binaryData);
                                log(`Sent binary message: ${jsonStr.substring(0, 100)}${jsonStr.length > 100 ? '...' : ''}`);
                            } else {
                                // Send as JSON string
                                data = JSON.stringify(message);
                                socket.send(data);
                                log(`Sent message: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);
                            }
                        } else {
                            // String message
                            socket.send(message);
                            log(`Sent message: ${message.substring(0, 100)}${message.length > 100 ? '...' : ''}`);
                        }
                        
                        messagesSent++;
                        messagesSentEl.textContent = messagesSent;
                        addMessage(message, 'sent');
                        
                        // Clear message error
                        messageErrorEl.textContent = '';
                    } catch (error) {
                        log(`Error sending message: ${error.message}`);
                        messageErrorEl.textContent = `Error: ${error.message}`;
                    }
                } else {
                    log('Cannot send message: WebSocket is not connected');
                    messageErrorEl.textContent = 'Error: WebSocket is not connected';
                }
            }
            
            // Event Listeners
            connectButton.addEventListener('click', connectWebSocket);
            disconnectButton.addEventListener('click', disconnectWebSocket);
            
            sendButton.addEventListener('click', () => {
                const messageType = messageTypeSelect.value;
                const content = messageContentTextarea.value;
                
                try {
                    let message;
                    
                    if (messageType === 'custom') {
                        // Parse custom JSON message
                        try {
                            message = JSON.parse(content);
                        } catch (error) {
                            messageErrorEl.textContent = `Invalid JSON: ${error.message}`;
                            return;
                        }
                    } else if (messageType === 'ping') {
                        message = {
                            type: 'ping',
                            timestamp: Date.now()
                        };
                    } else if (messageType === 'echo') {
                        message = {
                            type: 'echo',
                            message: content
                        };
                    } else if (messageType === 'heartbeat') {
                        message = {
                            type: 'heartbeat',
                            timestamp: Date.now()
                        };
                    } else {
                        // Regular message
                        message = {
                            type: 'message',
                            content: content
                        };
                    }
                    
                    sendMessage(message);
                } catch (error) {
                    log(`Error preparing message: ${error.message}`);
                    messageErrorEl.textContent = `Error: ${error.message}`;
                }
            });
            
            // Update message content based on type selection
            messageTypeSelect.addEventListener('change', () => {
                const messageType = messageTypeSelect.value;
                let template = '';
                
                switch (messageType) {
                    case 'message':
                        template = JSON.stringify({ type: 'message', content: 'Hello, WebSocket Server!' }, null, 2);
                        break;
                    case 'ping':
                        template = JSON.stringify({ type: 'ping', timestamp: Date.now() }, null, 2);
                        break;
                    case 'echo':
                        template = JSON.stringify({ type: 'echo', message: 'Echo this message back to me' }, null, 2);
                        break;
                    case 'heartbeat':
                        template = JSON.stringify({ type: 'heartbeat', timestamp: Date.now() }, null, 2);
                        break;
                    case 'custom':
                        template = JSON.stringify({ type: 'custom', customField: 'Custom value', data: { nested: 'object' } }, null, 2);
                        break;
                }
                
                messageContentTextarea.value = template;
            });
            
            // HTTP Fallback Functionality
            const httpSendButton = document.getElementById('http-send-button');
            const httpEndpointInput = document.getElementById('http-endpoint');
            const httpMessageTextarea = document.getElementById('http-message');
            const httpLogsEl = document.getElementById('http-logs');
            
            function httpLog(message) {
                const logItem = document.createElement('div');
                logItem.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                httpLogsEl.appendChild(logItem);
                httpLogsEl.scrollTop = httpLogsEl.scrollHeight;
            }
            
            httpSendButton.addEventListener('click', async () => {
                const endpoint = httpEndpointInput.value;
                let messageContent;
                
                try {
                    messageContent = JSON.parse(httpMessageTextarea.value);
                } catch (error) {
                    httpLog(`Error: Invalid JSON - ${error.message}`);
                    return;
                }
                
                httpLog(`Sending HTTP request to ${endpoint}`);
                
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(messageContent)
                    });
                    
                    const data = await response.json();
                    httpLog(`Received response: ${JSON.stringify(data, null, 2)}`);
                } catch (error) {
                    httpLog(`Error: ${error.message}`);
                }
            });
            
            // SSE Functionality
            const sseConnectButton = document.getElementById('sse-connect-button');
            const sseDisconnectButton = document.getElementById('sse-disconnect-button');
            const sseEndpointInput = document.getElementById('sse-endpoint');
            const sseLogsEl = document.getElementById('sse-logs');
            let eventSource = null;
            
            function sseLog(message) {
                const logItem = document.createElement('div');
                logItem.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                sseLogsEl.appendChild(logItem);
                sseLogsEl.scrollTop = sseLogsEl.scrollHeight;
            }
            
            sseConnectButton.addEventListener('click', () => {
                const endpoint = sseEndpointInput.value;
                sseLog(`Connecting to SSE endpoint: ${endpoint}`);
                
                try {
                    eventSource = new EventSource(endpoint);
                    
                    eventSource.onopen = () => {
                        sseLog('SSE connection opened');
                        sseConnectButton.disabled = true;
                        sseDisconnectButton.disabled = false;
                    };
                    
                    eventSource.onmessage = (event) => {
                        sseLog(`Received event: ${event.data}`);
                        try {
                            const data = JSON.parse(event.data);
                            sseLog(`Parsed data: ${JSON.stringify(data, null, 2)}`);
                        } catch (error) {
                            sseLog(`Error parsing event data: ${error.message}`);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        sseLog(`SSE error: ${error.type}`);
                        if (eventSource.readyState === EventSource.CLOSED) {
                            sseLog('SSE connection closed');
                            sseConnectButton.disabled = false;
                            sseDisconnectButton.disabled = true;
                        }
                    };
                } catch (error) {
                    sseLog(`Error connecting to SSE: ${error.message}`);
                }
            });
            
            sseDisconnectButton.addEventListener('click', () => {
                if (eventSource) {
                    sseLog('Closing SSE connection');
                    eventSource.close();
                    eventSource = null;
                    sseConnectButton.disabled = false;
                    sseDisconnectButton.disabled = true;
                }
            });
            
            // Diagnostics Functionality
            const browserInfoEl = document.getElementById('browser-info');
            const networkInfoEl = document.getElementById('network-info');
            const runDiagnosticsButton = document.getElementById('run-diagnostics');
            const diagnosticsLogsEl = document.getElementById('diagnostics-logs');
            
            function diagnosticsLog(message) {
                const logItem = document.createElement('div');
                logItem.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                diagnosticsLogsEl.appendChild(logItem);
                diagnosticsLogsEl.scrollTop = diagnosticsLogsEl.scrollHeight;
            }
            
            // Populate browser and network info
            function populateEnvironmentInfo() {
                // Browser info
                const browserInfo = [
                    `User Agent: ${navigator.userAgent}`,
                    `Platform: ${navigator.platform}`,
                    `Cookies Enabled: ${navigator.cookieEnabled}`,
                    `Language: ${navigator.language}`,
                    `Online: ${navigator.onLine ? 'Yes' : 'No'}`
                ];
                browserInfoEl.innerHTML = browserInfo.map(info => `<div>${info}</div>`).join('');
                
                // Network info
                const networkInfo = [
                    `Protocol: ${window.location.protocol}`,
                    `Hostname: ${window.location.hostname}`,
                    `Port: ${window.location.port || (window.location.protocol === 'https:' ? '443' : '80')}`,
                    `Path: ${window.location.pathname}`
                ];
                networkInfoEl.innerHTML = networkInfo.map(info => `<div>${info}</div>`).join('');
            }
            
            populateEnvironmentInfo();
            
            // Run diagnostics
            runDiagnosticsButton.addEventListener('click', async () => {
                diagnosticsLog('Running connection diagnostics...');
                
                // Test Web API support
                diagnosticsLog('Testing Web API support...');
                const apis = {
                    'WebSocket': typeof WebSocket !== 'undefined',
                    'EventSource (SSE)': typeof EventSource !== 'undefined',
                    'Fetch API': typeof fetch !== 'undefined',
                    'WebRTC': typeof RTCPeerConnection !== 'undefined',
                    'IndexedDB': typeof indexedDB !== 'undefined',
                    'Service Workers': 'serviceWorker' in navigator
                };
                
                for (const [api, supported] of Object.entries(apis)) {
                    diagnosticsLog(`${api}: ${supported ? 'Supported' : 'Not supported'}`);
                }
                
                // Test network connectivity
                diagnosticsLog('Testing network connectivity...');
                try {
                    const response = await fetch('/api/health');
                    const data = await response.json();
                    diagnosticsLog(`API health check: ${data.status}`);
                } catch (error) {
                    diagnosticsLog(`API health check failed: ${error.message}`);
                }
                
                // Test WebSocket connectivity
                diagnosticsLog('Testing WebSocket connectivity...');
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const testSocket = new WebSocket(`${protocol}//${window.location.host}/ws`);
                    
                    testSocket.onopen = () => {
                        diagnosticsLog('WebSocket test: Connection successful');
                        testSocket.close();
                    };
                    
                    testSocket.onerror = (error) => {
                        diagnosticsLog(`WebSocket test: Connection failed`);
                    };
                    
                    // Set a timeout for the test
                    setTimeout(() => {
                        if (testSocket.readyState !== WebSocket.OPEN) {
                            diagnosticsLog('WebSocket test: Connection timed out');
                            testSocket.close();
                        }
                    }, 5000);
                } catch (error) {
                    diagnosticsLog(`WebSocket test: Error - ${error.message}`);
                }
                
                diagnosticsLog('Diagnostics complete');
            });
            
            // Initialize - auto-populate the protocol and hostname
            log('WebSocket Connection Test Tool initialized');
        });
    </script>
</body>
</html>